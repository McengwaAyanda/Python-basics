# Python-basics

# Variables and Data types
> The fundamental building block of a program is a variable, which is assigned a specific value. The assignment operator used is the equal sign. In Jupyter Notebooks, you can execute cells by pressing Shift + Enter, and insert a new cell by clicking outside the margin and typing 'a'. Variable names cannot start with a number, but can include uppercase and lowercase letters, as well as underscores. It is a common convention in Python to start variable names with lowercase letters.
> Python supports several variable types, such as integers (whole numbers), floats (decimal numbers), complex numbers (for complex mathematical operations), and strings (collections of characters). Booleans, which represent true or false values, are also a variable type in Python. When working with strings, you can concatenate them using the plus sign, but you cannot add strings and numbers directly. Error messages can provide valuable information when programming in Python, helping you identify and resolve issues.

# Data Structures
> Python offers various data structures that allow you to store and manage collections of values in a single variable. The first data structure introduced is the list, which can contain elements of any data type, including other lists. You can determine the length of a list using the length function.
> Another data structure is the 'set', which is similar to a list but only contains unique elements. Sets are declared using curly braces, and the order of elements in a set is not important, unlike in a list.
> Tuples are also similar to lists, but they cannot be modified once declared. Tuples are useful for efficiently storing large amounts of data in memory, such as coordinate pairs.
> Finally, the dictionary is a data structure that stores key-value pairs, resembling a word and its definition in a book. Dictionaries are declared using curly braces and accessed using the keys.
> These data structures provide flexibility and organization in Python programming, allowing you to manage and manipulate collections of data in various ways.

# Operators
> In Python, operators are instructions that perform various operations on variables and values. The most familiar type of operator is the arithmetic operator, which is used for mathematical calculations. Examples include the addition operator (+), which adds two numbers together, the multiplication operator (*), which multiplies numbers, and the exponent operator (**), which raises a number to a specified power.
> The division operator (/) performs division and returns a floating-point value, even if the result is a whole number. The modulus operator (%), on the other hand, provides the remainder after division, which can be useful in various programming applications.
> Operators can also be used to manipulate strings. The addition operator (+) can concatenate or combine two strings, while the multiplication operator (*) can repeat a string a certain number of times. However, the addition operator for strings works only with two strings, while the multiplication operator can work with either a string or a number.
> Python also has other types of operators, such as comparison operators (e.g., ==, <, >, <=, >=), logical operators (e.g., and, or, not), and membership operators (e.g., in, not in). Comparison operators evaluate two values and produce a Boolean result (true or false), while logical operators operate on Boolean values. Membership operators are used to check whether a value is present in a sequence, such as a list or a string.
> These operators provide a rich set of tools for manipulating and working with data in Python. While the concepts may seem overwhelming at first, practicing the usage of these operators will help you become more proficient in Python programming.

# Control Flow
> In Python, the 'if' statement is one of the primary control flow mechanisms. It allows you to execute a block of code only when a specific condition is met. The basic structure is: "if condition: [indented code block]". If the condition evaluates to True, the indented code will be executed. You can also add an 'else' statement to specify an alternative code block to be executed when the condition is False.
> Indentation is crucial in Python, as it determines the structure and flow of the program. It's used to group and nest code blocks.
> Another control flow structure is the 'for' loop, which allows you to iterate over a list or any other iterable object. The syntax is: "for item in my_list: [indented code block]". The 'item' variable represents the current element being processed in the iteration.
> The 'while' loop is similar, but it keeps executing the code block as long as a given condition remains True. The syntax is: "while condition: [indented code block]".
> It's important to ensure that the condition will eventually become False, or else the loop will run indefinitely.
> These control flow statements - 'if', 'for', and 'while' - are fundamental building blocks that allow you to write more complex and dynamic programs in Python, by controlling the execution of different code paths based on specific conditions or iterative processes.

# Functions
> In Python, a function is like a self-contained machine that takes inputs, performs some operation on them, and produces an output. It's similar to a toaster that takes in bread and produces toast, even if the input is not bread.
> To define a function in Python, you use the 'def' keyword followed by the function name and any arguments it requires, enclosed in parentheses. The function body, which contains the code that performs the desired operation, is indented. The 'return' keyword is used to specify the output of the function.
> Functions can take one or more arguments, and they may or may not return a value. Some functions may modify a variable without returning anything. The 'print' function, for example, is a function that outputs something to the console but doesn't return a value.
> If a function doesn't explicitly return anything, the default return value is 'None', which represents the absence of a value in Python.
> Functions allow you to encapsulate and reuse specific pieces of functionality within your code, making your programs more modular, maintainable, and efficient.

# Classes and Objects
> In the previous sections, we focused on the functionality of a single appliance, a toaster. However, to create a complete kitchen, we need various appliances with different capabilities, such as toasting, baking, microwaving, dishwashing, and coffee making. Each appliance may have its own unique settings and controls.
> If we want to build multiple kitchens with different appliance sets or even entire houses with various rooms and functions, writing extensive and unmanageable code with numerous functions and variables could become a challenge. To address this issue, programmers introduced a tool called a 'class' in Python, which allows you to organize and manage related collections of functions and attributes.
> As an example, we can create a 'Dog' class, as a dog has multiple functions (e.g., barking) and attributes (e.g., legs, name). When defining a class, we use an uppercase letter for the class name and include all the functions and attributes within the class definition.
> The class usually begins with a special function called the 'init' (initialization) function, which is called every time an instance of the class is created. The 'init' function takes a variable called 'self', which refers to the specific instance of the class.
> Inside the class, we can define the attributes and functions of the Dog class. For example, we can create a Dog with four legs and the name "Rover", and a 'speak' function that prints "bark". We can access the attributes and functions using the 'self' variable.
> To use this class, we create a new instance of the class by calling 'dog' and passing any necessary variables, such as the dog's name. We can create multiple dog objects, each with its own set of attributes and functions.
> The 'speak' function takes 'self' as the first parameter, which represents the instance of the class that the function is called on. These class instances are called 'objects', and the variables inside the class are called 'attributes', while the functions are called 'methods'.
> This is a brief introduction to the concepts and terminology of object-oriented programming, which can be a powerful and useful programming paradigm.

# Ints and Floats
> Let's revisit two fundamental number types in Python: integers (ints) and floating-point numbers (floats). We'll take a closer look at how they interact, how to convert between them, and some common pitfalls to be aware of.
> In our previous example, we saw that division with integers returns a float, such as 20 divided by 4 resulting in 5.0. Python automatically returns a float to accommodate non-whole numbers. Adding a float to an int, or performing operations like multiplication or exponents with both, also returns a float.
> To convert a float back to an int, we can use the 'int' class, not the 'int' function. This process is called 'casting'. When casting from a float to an int, Python simply removes the decimal part, rather than rounding. For example, casting 8.9 to an int results in 8, not 9. To round a float to the nearest int, we can use the 'round' function.
> One pitfall of floats is that they are approximations, which can lead to rounding errors. For instance, 1.2 minus 1.0 might not result in exactly 0.2 due to the way floats are stored in binary in computer memory. This is because floats are limited by the available memory, and Python must make approximations.
> While the 'round' function can help mitigate these rounding issues, it's essential to be cautious when working with floats, particularly in situations where decimal places are significant, such as handling money. In the next section, we'll explore some ways to deal with decimals when working with financial data.

# Alternative Number Types
> The int class in Python has some interesting capabilities. If you pass a number represented as a string, the int class will convert it to an integer. For example, the string "100" will become the integer 100.
> What's really neat is that you can also pass a second argument to the int class, which specifies the base of the first argument. This allows you to convert a number from a different base (like binary or hexadecimal) to base 10. For instance, the string "100" in base 2 is equivalent to the integer 4 in base 10.
> However, the first argument passed to the int class must always be a string, even if you're converting from a different base. This is because the string may contain non-numeric characters that are valid in some bases, like "1ab" in base 16, which is not a valid integer.
> Python also has a decimal class that addresses some of the issues with floating-point numbers (floats). Floats can suffer from floating-point errors, which can be problematic in certain situations, such as when dealing with money.
> To use the decimal class, you need to import the decimal class and the getcontext function at the top of your code. The getcontext function returns a context object that holds global settings for the decimal class, which you can modify to change things like the precision.
> With the decimal class, you can create decimal objects with numeric values. For example, the expression decimal(1) divided by decimal(3) will return 0.3333 with four decimal places. You can also pass a float to the decimal class, but be aware that it will try to exactly replicate the float, which may lead to floating-point errors. In such cases, it's better to pass the float as a string.
> While the decimal class can be useful in certain situations, it's not always necessary to use it instead of floats. For most common use cases, floats work just fine. The key is to remember to round values appropriately before presenting them to users, particularly when dealing with small or large numbers.

# Booleans
> Despite Booleans in Python seeming straightforward (true or false), there are some nuanced and tricky aspects to them that programmers need to be aware of. It's often helpful to check the Python terminal to ensure you're using boolean logic correctly.
> First, let's discuss casting. Python easily casts integers to Booleans - the integer 1 is considered true, and 0 is considered false. In fact, anything except 0 is evaluated as true, including negative integers and imaginary numbers. However, the float 0 and imaginary 0 are considered false.
> When it comes to strings, the boolean value "true" is true, and any non-empty string is also considered true. The only false string is an empty one, so be careful not to accidentally include a space, which would make it a non-empty string.
> Data structures can also be cast to Booleans. An empty list or dictionary is considered false, but anything inside them is true. Additionally, when a function returns a non-value, it is cast to false.
> Understanding boolean casting is crucial because Booleans are commonly used in if statements and loops, so we need to know how to properly evaluate their values. For example, casting a list to a boolean can be used to check if it has any values in it.
> There's often more than one way to evaluate a boolean expression, so we need to be careful about the logic. For instance, if we want to decide whether to go for a walk based on the weather and whether we have an umbrella, we need to use parentheses or the "and" operator to get the correct logic, as Python evaluates boolean expressions from left to right.
> In summary, while Booleans may seem simple, it's crucial for programmers to understand the nuances of boolean casting and logic in Python. Always think carefully about how Python will evaluate each part of a boolean expression, and double-check your work to ensure the correct logic is being applied.

# Strings
> Python involves a lot of work with strings, whether it's parsing them to extract data or constructing them to present information to the user. Fortunately, Python provides numerous tools to analyze and manipulate strings, and one of the most useful is slicing.
> Slicing refers to the ability to extract a portion of a string and return it. For example, if we have the string "My name is Iron-Man," we can get the first character using the syntax name[0], since programmers start counting from zero. We can also get the second character with name[1]. To get the first seven characters of the string, we can use name[0:7], which includes the characters from index 0 up to but not including index 7. There's also a shorthand syntax for this, where we can simply use name[7] to get the same result. If we want to get all the characters from index 11 to the end of the string, we can use the syntax name[11:], leaving the end of the string unspecified.
> It's important to note that the slicing syntax is the same for both strings and lists in Python. For instance, we can take a slice of the list [1, 2, 3, 4, 5] with the syntax my_list[2:4]. Lists and strings have many similarities in Python, and we can even use the len() function to get the length of a string or a list.
> Python provides several ways to create strings, including string concatenation and f-strings. F-strings allow us to insert variables or expressions directly into a string, enclosed within curly braces. We can also use f-strings for rounding and number formatting. The format function is similar to f-strings and was used in versions of Python prior to 3.6.
> Another useful feature in Python is the ability to create multi-line strings using triple quotes. If we need to include literal triple quotes within the string, we can escape them with a backslash.
> Python has a wide range of string functions and methods, and we'll cover more of them in the future. For now, you can refer to the official Python documentation for more information on working with strings in Python.

# Bytes
> Let's talk about the Python byte object. It's not something you'll work with daily, but it's used behind the scenes in programs. It's data that's passed around but rarely modified directly. When computers store information, it's done as ones and zeros.
> When Python loads that data, it knows what type it is - string, integer, class, etc. But sometimes, all you want is raw data, like a random sequence of ones and zeros. That's where the bytes object comes in. It's just a sequence of data, and Python doesn't need to know anything else about it. The bytes object is commonly used for streaming files or transmitting texts without knowing the encoding.
> Let's take a look at how to recognize and use the bytes object. First, you can create an empty bytes object that's four bytes long. This is represented as \x followed by two hexadecimal numbers. Each byte has eight bits. If you see a b in front of something printed out, it's a bytes object. To create a bytes object with actual data in it, like an emoji, you need to tell Python the type, like UTF-8. Once it knows the format, it can represent the data correctly. You can also use the decode function to turn a bytes object back into a string.
> Bytes objects are immutable, like tuples, but you can use a byte array if you need to modify the data. You can treat a byte array like a string and modify specific byte values using slice notation. You can use the int library to convert hexadecimal values, like a shrugging emoji, back to bytes. That's how to find, detect, use, and modify bytes in Python.

# Lists
> We've covered strings in Python, which are similar to lists and use the same slicing syntax. Slicing can be used to extract a range of values from a list or string, and you can also add a third value to control the step size. The range() function can be used to generate longer lists, which can also be sliced. Negative values can be used to step backward through the list. These operations allow for the extraction of data from lists or strings one value at a time.
> In this section, we'll learn how to modify lists in Python. To add an item to the end of a list, we can use the append() method. For example, if we have a list myList with the values 1, 2, 3, 4, we can append the value 5 to it by typing myList.append(5) and then printing myList.
> If we want to insert an item at a specific position in the list, we can use the insert() method. For instance, if we want to insert the value 10 at position 3 in myList, we can type myList.insert(3, 10) and then print myList.
> There are two ways to remove items from a list. The first method is called remove(), which removes an item based on its value, not its index. For instance, if we want to remove the value 5 from myList, we can type myList.remove(5) and then print myList. However, if we try to remove a value that isn't in the list, we will get an error.
> The second method to remove items from a list is pop(). This method removes and returns the item at the end of the list. For example, if we type myList.pop() and then print myList, the last item will be removed from myList.
> We can also use a loop with pop() to remove all items from the list. For example, we can use a while loop with the condition while len(myList) > 0: and inside the loop, we can print myList.pop(). After the loop, the list will be empty.
> When we assign a list to a variable, the variable stores a reference to the list, not a copy of the list. This means that if we modify the list through one variable, the changes will be reflected in the other variables that reference the same list. However, if we want to make a copy of a list so that changes to one list don't affect the other, we can use the copy() method. For example, if we have a list a with the values 1, 2, 3, 4, 5 and we want to make a copy of it, we can type b = a.copy() and then print both a and b to see the difference between them.
> Lists are an essential and powerful data structure in Python, and it's essential to understand how to work with them. It's a good idea to experiment with them and try out the different methods discussed here to get comfortable with their functionality.

# Tuples and Sets
> Let's take a closer look at two data structures we've covered before: tuples and sets.
> First, sets. A set is defined using curly braces, like this: {'a', 'b', 'c'}, mySet. You can also define a set by passing any iterable object to the set constructor, like this: mySet = set(('a', 'b', 'c')).
> One common use of sets is to remove duplicates from a list, since sets only contain unique values. To demonstrate, let's create a list with some duplicate values and de-duplicate it by converting it to a set and back again: myList = ['b', 'c', 'c'] mySet = list(set(myList)).
> Sets are not ordered lists, but rather unordered collections of elements. You can't access elements in a set using an index or slicing syntax. However, you can add elements to a set using the add() function and remove elements using the discard() function. You can check if an element is in a set using the 'in' operator, and find the length of a set using the length() function. Sets also have a pop() function that removes and returns an arbitrary element.
> Now, let's talk about tuples. They're similar to lists, but they're declared with parentheses instead of square brackets. For example, a tuple called myTuple with elements 'a', 'b', and 'c' requires commas in between them. Tuples are ordered and subscriptable like lists, but they are immutable, meaning you can't modify them. You can retrieve elements from a tuple using indexing, but you'll get an error if you try to modify them.
> Despite their immutability, tuples are more efficient than lists because they take up less memory, making them a good option for storing large amounts of data. One common use case for tuples is when you want to return multiple values from a function. You can separate the values with commas, and Python will automatically create a tuple. You can also unpack the values in a tuple into individual variables using the syntax A, B, C = myTuple.
> So while tuples may not be as flexible as lists, they offer convenience and elegance in certain situations.

# Dictionaries
> In Python, you'll commonly work with two main data structures: lists and dictionaries. Combining these can solve the majority of your data structure needs. Let's look at some examples using a dictionary of animals.
> You may notice a comma at the end of the last key-value pair in the dictionary - this is called a trailing comma, and while not strictly necessary, it's considered good practice.
> To access a specific key-value pair, you use the dictionary name followed by the key in square brackets. To add a new pair, you use similar syntax with the assignment operator. To update an existing pair, you just access it and reassign the value. 
> You can also access the keys and values of a dictionary using the .keys() and .values() methods, respectively. The .keys() method returns a dict_keys object, which is immutable - you need to convert it to a list to modify it. If you try to access a non-existent key, you'll get an error, but you can use the .get() method to provide a default value instead.
> Another pattern is a dictionary where the values are lists. Adding to these is straightforward if the key already exists, but you may need to use an if-else statement to handle cases where the key doesn't exist yet. You can also use the len() function to get the length of a dictionary.
> If this all seems a bit complicated, there's a solution called the defaultdict, which you can import from the collections package. With a defaultdict, you specify the default object type it should return, and it will automatically create a new default value if a key doesn't exist, instead of raising an error.
> While combining lists and dictionaries is powerful in Python, the language offers even more advanced data structures beyond that!

# List Comprehensions
> Python's list comprehension is a powerful feature that sets it apart from other programming languages. List comprehension allows you to concisely create a new list by applying an operation to each item in an existing list.
> For example, if you have a list of numbers, you can use list comprehension to multiply each item by 2 in a single line of code. The list comprehension syntax is similar to a for loop, enclosed in square brackets.
> List comprehension can also be used as a filter. Suppose you have a list of numbers from 0 to 99. You can use list comprehension to create a new list containing only the numbers that are divisible by 10, or those that end in 0, 1, or 2.
> List comprehension isn't limited to numbers - you can use it with strings as well. For example, you can split a string into a list of words, and then use list comprehension to convert each word to lowercase and remove any periods.
> To make the output more readable, you can create a custom function, like "cleanWord," and apply it to each word using list comprehension.
> A more advanced technique is nested list comprehension, which allows you to perform operations on each element of a list of lists. For instance, you can split a string into sentences, clean each word in each sentence, and group the cleaned words by the sentence they appeared in, all in a single line of code.
> List comprehensions are a powerful and concise way to manipulate data in Python. By using them, you can write more readable and "Pythonic" code, which can be especially useful when working with large amounts of data.

# Dictionaries and Comprehensions
> In Python, you can use dictionary comprehensions to create a new dictionary from an iterable structure, similar to how list comprehensions create a new list. For example, if you have a list of key-value tuples, you can use the dictionary comprehension syntax `{key: value for item in iterable}` to create a dictionary directly from the list.
> There's an even more concise way to write this dictionary comprehension using tuple unpacking. Instead of accessing the tuple elements by index (`item[0]` and `item[1]`), you can use the key and value variable names directly in the comprehension: `{key: value for (key, value) in iterable}`. This makes the code more readable, but you need to make sure the tuples in the iterable have the right number of elements.
> If you want to convert the dictionary back into a list, you can use the `items()` method, which returns a `dict_items` object containing the key-value pairs. You can then convert this object to a list using the `list()` function.
> Going further, you can use a list comprehension to transform the dictionary into a list of dictionaries, where each dictionary has a "name" and "value" field corresponding to the original key and value. This demonstrates the flexibility of both dictionary and list comprehensions for manipulating and formatting data in Python.
> In summary, dictionary comprehensions provide a concise way to create new dictionaries from iterables, and combining them with list comprehensions allows for powerful data transformations and formatting.

